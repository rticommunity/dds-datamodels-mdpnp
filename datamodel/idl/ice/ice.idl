@annotation doc {
    string value default "TBD";
};

@doc("@author Jeff Plourde \
    These are the data types and topic names used by the OpenICE system. \
    A nominal level of namespacing.  In java this will create an ice \
    package.  In C++ this will create a namespace.  In C this will create \
    a name prefix.  Type names will also be scoped with an \"ice::\" prefix. \
    We do not use such a prefix in topic names because colons are not legal \
    characters for use in DDS topics per section A.2 of the DDS spec version 1.2 \
    http://www.omg.org/spec/DDS/1.2/ \
    Excerpted... \
    TOPICNAME - A topic name is an identifier for a topic, and is defined as any \
    series of characters 'a', ..., 'z', 'A', ..., 'Z', '0', ..., '9', '-'' but may \
    not start with a digit. \
    The stability of each data model element will be ranked on a scale 0 to 5. \
    For more information on the stability levels. \
    http://nodejs.org/api/documentation.html#documentation_stability_index \
    A better definition of backward-compatibility is required here with respect to the \
    Extensible Types Addendum to DDS.  i.e. backward compatibility is influenced \
    by the use of markers for extensible types (indicating parameterized CDR) \
    http://www.omg.org/spec/DDS-XTypes/")
module ice {
  @doc("A placeholder type for evolving FDA work on UDI.  Thus far 64 ISO-8859-1 characters \
      is sufficient for holding FDA mandated unique device identifiers but we should \
      monitor for changes. \
      http://www.fda.gov/MedicalDevices/DeviceRegulationandGuidance/UniqueDeviceIdentification/")
  typedef string<64> UniqueDeviceIdentifier;

  @doc("A type for representing nomenclature codes from the ISO/IEEE 11073-10101 along with \
      further work by the Rosetta Terminology Mapping project as maintained by NIST: \
      https://rtmms.nist.gov/rtmms/index.htm \
      64 ISO-8859-1 characters is sufficient to utilize any \"MDC\" code currently accepted \
      in harmonized rosetta.")
  typedef string<64> MetricIdentifier;

  @doc("A type for representing identifying information from a proprietary vendor nomenclature.")
  typedef string<64> VendorMetricIdentifier;

  @doc("For multiple instances of the same sensor this type is used for disambiguation. \
    TODO Must these always begin at 0?")
  typedef long InstanceIdentifier;

  @doc("A type for representing unit codes from the ISO/IEEE 11073-10101 along with further \
    work by the Rosetta Terminology Mapping project as maintained by NIST: \
    https://rtmms.nist.gov/rtmms/index.htm")
  typedef string<64> UnitIdentifier;

  @doc("A type for \"long\" string fields such as those descriptive of persons, places, and \
    things.  These are UTF32 encoded to support international use.")
  typedef wstring<128> LongString;

  @doc("For a connected device these are the valid targets the device adapter might connect \
    to. These are often the names of serial (RS-232) ports available on the adapter.")
  typedef sequence<LongString, 128> ValidTargets;

  @doc("Contains image data with the type specified externally.")
  typedef sequence<octet, 65530> ImageData;

  @doc("A sequence of values sampled at a high data rate (> 3Hz)")
  typedef sequence<float, 1024> Values;

  @doc("Definition for absolute time since the epoch in nanosecond resolution in the spirit \
    of the built-in DDS type and the \"struct timespec\" structure. \
    http://pubs.opengroup.org/onlinepubs/7908799/xsh/time.h.html")
  @nested
  struct Time_t {
    long sec;
    long nanosec;
  };

  @doc("At regular intervals (currently every 2 seconds) every OpenICE participant should \
    publish to this topic. When the instance of HeartBeat associated with a device is \
    no longer alive that device should be considered disconnected from the system. The \
    Type description indicates whether the heartbeat came from a Device or Supervisor. \
    Stability: 2 - Unstable \
              An emitted sample from a particular uniquely identified device is \
              necessary to determine device presence; however the particulars may \
              change.")
  @extensibility(MUTABLE)
  struct HeartBeat {
    @key UniqueDeviceIdentifier unique_device_identifier;
    string<32> type;
  };

  const string HeartBeatTopic = "HeartBeat";

  @doc("Upon receipt of a HeartBeat sample an OpenICE participant should publish to this \
    topic the original source timestamp of that heartbeat as well as the reception \
    time. When this TimeSync message arrives back at the participant which originated \
    the heartbeat enough information has been gathered to ascertain clock \
    synchronization. So a Supervisory participant can determine whether any device \
    clocks are out of sync. \
    Stability: 1 - Experimental \
              It is unclear whether the overhead created by this exceeds the benefit \
              of detecting a lack of clock synchronization.")
  @extensibility(MUTABLE)
  struct TimeSync {
    @key UniqueDeviceIdentifier heartbeat_source;
    @key UniqueDeviceIdentifier heartbeat_recipient;
    Time_t source_source_timestamp;
    Time_t recipient_receipt_timestamp;
  };

  const string TimeSyncTopic = "TimeSync";

  @doc("Structure that includes binary image data encoded in the specified MIME type.")
  @nested
  struct Image {
    string<64> content_type;
    ImageData image;
  };

  @doc("DeviceIdentity allows a device to share identifying information. A device generally \
    publishes this information only once. A device with a further connection, perhaps a \
    serial RS-232 link, might publish details like serial number only after they become \
    available. \
    Stability: 2 - Unstable")
  @extensibility(MUTABLE)
  struct DeviceIdentity {
    @key UniqueDeviceIdentifier unique_device_identifier;
    LongString manufacturer;
    LongString model;
    LongString serial_number;
    Image icon;
    string<128> build;
    string<128> operating_system;
  };

  const string DeviceIdentityTopic = "DeviceIdentity";

  @doc("For a further connected device (device 'adapter') this enumerates the possible \
    states of the further connection to a device.")
  enum ConnectionState {
    @doc("Connection is not yet initialized")
    Initial,
    @doc("Connection is initialized and data is flowing normally")
    Connected,
    @doc("Connection has been physically made (perhaps an open socket or serial port) but \
        no information has been exchanged")
    Connecting,
    @doc("Information exchange has commenced to establish the connection.  Some devices may \
        skip this state.")
    Negotiating,
    @doc("Connection has been shut down in anticipation of the termination of the device adapter")
    Terminal
  };

  @doc("For a further connected device (device 'adapter') this enumerates the possible \
    natures of the further connection.")
  enum ConnectionType {
    @doc("An RS-232 connection")
    Serial,
    @doc("A simulator that emulates connected device behaviors.")
    Simulated,
    @doc("A network connection (typically IP/Ethernet)")
    Network
  };

  @doc("DeviceConnectivity shares information about a device that has a further connection \
    to another device, such as a serial RS-232 link. The status of that further \
    connection is published as well as additional information about the connection \
    (often details about the connection process). Targets are also provided for an \
    associated objective topic whereby establishment of the further connection can \
    be requested by another participant. All current OpenICE device adapters attempt \
    to establish such a connection by default. \
    Stability: 2 - Unstable")
  @mutable
  struct DeviceConnectivity {
    @key UniqueDeviceIdentifier unique_device_identifier;
    ConnectionState state;
    ConnectionType type;
    LongString info;
    ValidTargets valid_targets;
    string<16> comPort;
  };
  const string DeviceConnectivityTopic = "DeviceConnectivity";

  @doc("MDSConnectivity \
    Stability: 2 - Unstable")
  @extensibility(MUTABLE)
  struct MDSConnectivity {
    @key UniqueDeviceIdentifier unique_device_identifier;
    string<128> partition;
  };
  const string MDSConnectivityTopic = "MDSConnectivity";

  @doc("This topic allows a participant to instruct a connected device adapter \
    to configure itself. \
    Stability: 2 - Unstable")
  @extensibility(MUTABLE)
  struct MDSConnectivityObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    string<128> partition;
  };

  const string MDSConnectivityObjectiveTopic = "MDSConnectivityObjective";

  /**
   * A number of speculative nomenclature codes not (yet) included in the
   * harmonized rosetta.
   */
  const string MDC_PRESS_CUFF_NEXT_INFLATION = "MDC_PRESS_CUFF_NEXT_INFLATION";
  const string MDC_PRESS_CUFF_INFLATION = "MDC_PRESS_CUFF_INFLATION";

  const string MDC_HR_ECG_MODE = "MDC_HR_ECG_MODE";
  const string MDC_RR_APNEA = "MDC_RR_APNEA";
  const string MDC_SPO2_C_LOCK = "MDC_SPO2_C_LOCK";
  const string MDC_TIME_PD_INSPIRATORY = "MDC_TIME_PD_INSPIRATORY";
  const string MDC_START_INSPIRATORY_CYCLE = "MDC_START_INSPIRATORY_CYCLE";
  const string MDC_START_EXPIRATORY_CYCLE = "MDC_START_EXPIRATORY_CYCLE";
  const string MDC_END_OF_BREATH = "MDC_END_OF_BREATH";
  const string MDC_VENT_TIME_PD_PPV = "MDC_VENT_TIME_PD_PPV";

  const long MDC_EVT_STAT_NBP_DEFL_AND_MEAS_BP = 6250;
  const long MDC_EVT_STAT_NBP_INFL_TO_MAX_CUFF_PRESS = 6222;
  const long MDC_EVT_STAT_OFF = 6226;

  // These leads appear in 11073-10101-2004
  // but are absent from Rosetta
  const string MDC_ECG_LEAD_I = "MDC_ECG_LEAD_I";
  const string MDC_ECG_LEAD_II = "MDC_ECG_LEAD_II";
  const string MDC_ECG_LEAD_III = "MDC_ECG_LEAD_III";
  const string MDC_ECG_LEAD_V1 = "MDC_ECG_LEAD_V1";
  const string MDC_ECG_LEAD_V2 = "MDC_ECG_LEAD_V2";
  const string MDC_ECG_LEAD_V3 = "MDC_ECG_LEAD_V3";
  const string MDC_ECG_LEAD_V4 = "MDC_ECG_LEAD_V4";
  const string MDC_ECG_LEAD_V5 = "MDC_ECG_LEAD_V5";
  const string MDC_ECG_LEAD_V6 = "MDC_ECG_LEAD_V6";
  const string MDC_ECG_LEAD_AVR = "MDC_ECG_LEAD_AVR";
  const string MDC_ECG_LEAD_AVF = "MDC_ECG_LEAD_AVF";
  const string MDC_ECG_LEAD_AVL = "MDC_ECG_LEAD_AVL";

  // These are some things for Sp02 device information
  // and control.

  @doc("Can the device return the averaging rate through the software interface? \
    0 denoted no, 1 denotes yes")
  const string SP02_SOFT_CAN_GET_AVERAGING_RATE = "SP02_SOFT_CAN_GET_AVERAGING_RATE";
  @doc("Can the operator get the device averaging rate?")
  const string SP02_OPER_CAN_GET_AVERAGING_RATE = "SPO2_OPER_CAN_GET_AVERAGING_RATE";
  @doc("What is the current device averaging rate?")
  const string SP02_AVERAGING_RATE = "SP02_AVERAGING_RATE";
  @doc("Can the operator set the device averaging rate?")
  const string SP02_OPER_CAN_SET_AVERAGING_RATE = "SP02_OPER_CAN_SET_AVERAGING_RATE";
  @doc("Can the device averaging rate be set through the software interface")
  const string SP02_SOFT_CAN_SET_AVERAGING_RATE = "SP02_SOFT_CAN_SET_AVERAGING_RATE";
  @doc("A class to be used as a numeric placeholder for a respiratory rate derived by \
    OpenICE, rather than received from a device itself.  First use is in the Draeger \
    Apollo")
  const string ICE_DERIVED_RESPIRATORY_RATE = "ICE_DERIVED_RESPIRATORY_RATE";

  @doc("Numerics are values observed by sensors at a relatively slow rate; generally <=3Hz. \
    Multiple sensors may exist for the same metric so the instance_id serves to \
    distinguish between them. If a timestamp is available from the device's internal \
    clock it is specified as device_time. A device ought to register an instance of \
    Numeric when the associated sensor might provide observations. If the sensor is \
    physically disconnected or otherwise certain not to provide samples then the \
    associated instance should be unregistered. Sensors are encouraged to publish a \
    new sample whenever a new observation is made even when the same value is observed. \
    In this way subscribers are made aware of the timeliness of the observation. \
    vendor_metric_id is informational only, may be left blank, and must not be expected. \
    If non-blank it contains a nomenclature code from a proprietary interface. \
    Stability: 2 - Unstable")
  @extensibility(MUTABLE)
  struct Numeric {
    @key UniqueDeviceIdentifier unique_device_identifier;
    @key MetricIdentifier metric_id;
    @key VendorMetricIdentifier vendor_metric_id;
    @key InstanceIdentifier instance_id;
    @key UnitIdentifier unit_id;
    float value;
    Time_t device_time;
    Time_t presentation_time;
  };
  const string NumericTopic = "Numeric";

  @doc("SampleArrays are values observed by sensors at a relatively high rate; generally \
    >3Hz. Multiple sensors may exist for the same metric so the instance_id serves to \
    distinguish between them. If a timestamp is available from the device's internal \
    clock it is specified as device_time. A device ought to register an instance of \
    SampleArray when the associated sensor might provide observations. If the sensor \
    is physically disconnected or otherwise certain not to provide samples then the \
    associated instance should be unregistered. Sourcetimestamp and device_time should \
    both represent the point in time at the end of the sample array. \
    vendor_metric_id is informational only, may be left blank, and must not be expected. \
    If non-blank it contains a nomenclature code from a proprietary interface. \
    Stability: 2 - Unstable")
  @extensibility(MUTABLE)
  struct SampleArray {
    @key UniqueDeviceIdentifier unique_device_identifier;
    @key MetricIdentifier metric_id;
    @key VendorMetricIdentifier vendor_metric_id;
    @key InstanceIdentifier instance_id;
    @key UnitIdentifier unit_id;
    @key long frequency;
    Values values;
    Time_t device_time;
    Time_t presentation_time;
  };
  const string SampleArrayTopic = "SampleArray";

  @doc("Speculative topic used for the PCA demonstration. The supervisory safety app \
    publishes a sample with stopInfusion=1 to indicate the infusion pump may not \
    infuse. Currently a third topic, indicating that the pump has acknowledged \
    the safety interlock, has not yet been included. We should also explore the \
    possibility of a setup whereby the pump receives periodic 'ok to infuse' \
    information and stops when that information is not received. \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct InfusionObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    LongString requestor;
    boolean stopInfusion;
  };
  const string InfusionObjectiveTopic = "InfusionObjective";

  @doc("SK - Topic for setting the averaging rate of a pulse oximetry device. \
    The \"Oximetry Devices\" app will publish a sample with averageTime=N to \
    indicate that that is the desired averaging time. ICE compliant devices \
    that can have their timing set will already be publishing their current \
    averaging rate, and so the acknowledgement will come from that parameter \
    changing \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct OximetryAveragingObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    LongString requestor;
    long newAverageTime;
  };
  const string OximetryAveragingObjectiveTopic = "OximetryAveragingObjective";

  @doc("SK - Topic for setting the flow rate in a Pump device. \
    The \"Pump Control\" app will publish a sample with flowRate=N to \
    indicate that this is the desired flow rate.  ICE compliant devices \
    that can have their flow rate set will already be publishing their current \
    flow rate, and so the acknowledgement will come from that parameter changing. \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct FlowRateObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    LongString requestor;
    float newFlowRate;
  };
  const string FlowRateObjectiveTopic = "FlowRateObjective";

  @doc("SK - Topic for changing the BP published by the SimControllableBPMonitor. \
    That simulated device is (initially) used as part of the Closed Loop Control \
    application.  We will have another application that will be used to adjust the \
    BP produced by the device.  Note that the value is how much to change the current \
    value by - NOT a new target")
  @extensibility(MUTABLE)
  struct BPObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    LongString requestor;
    float changeBy;
  };
  const string BPObjectiveTopic = "BPObjective";

  @doc("SK - Topic to ask out controllable BP monitor to pause or resume. \
    This will be used to test alarm production in the FROA app, that is required \
    to produce alarms when the BP monitor stops producing a signal")
  @extensibility(MUTABLE)
  struct BPPauseResumeObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    LongString requestor;
    boolean running;
  };
  const string BPPauseResumeObjectiveTopic = "BPPauseResumeObjective";

  @doc("Speculative topic used for the PCA demonstration. Only currently used by infusion \
    pump simulators. But this is meant to represent the current state of an infusion \
    pump holistically and coherently. While this is an early guess at some appropriate \
    fields it does make it evident that many of these fields are not safely \
    separable and should be part of the same data sample. \
    Stability: 0 - Deprecated")
  @extensibility(MUTABLE)
  struct InfusionStatus {
    @key UniqueDeviceIdentifier unique_device_identifier;
    @doc("is the pump actively infusing?")
    boolean infusionActive;

    @doc("it's entirely unclear if patient id, care area, BSA, etc. should be here")

    @doc("measurement units are standardized to avoid inconsistent states \
        derived values are omitted to avoid inconsistent states")

    @doc("what's in the bag")
    wstring<128> drug_name;
    long drug_mass_mcg;
    long solution_volume_ml;
    @doc("concentration can be derived")

    @doc("what's the program")
    long volume_to_be_infused_ml;
    long infusion_duration_seconds;
    @doc("rate can be derived")

    @doc("what is the progress through the program?")
    float infusion_fraction_complete;
  };
  const string InfusionStatusTopic = "InfusionStatus";

  @doc("Type of alarm limit for the settings of Alarms")
  enum LimitType {
    low_limit,
    high_limit
  };

  @doc("Priority of an alarm")
  enum AlarmPriority{
    low,
    medium,
    high
  };

  @doc("An alarm limit for a particular metric on a device \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct AlarmLimit {
    @key UniqueDeviceIdentifier unique_device_identifier;
    @key MetricIdentifier metric_id;
    @key LimitType limit_type;
    //AlarmPriority alarm_priority; //
    UnitIdentifier unit_identifier;
    float value;
  };
  const string AlarmLimitTopic = "AlarmLimit";


  @doc("This objective is published by a Supervisory participant to request that all \
    participants use the specified thresholds (Limits) for alarms on a particular metric. \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct GlobalAlarmLimitObjective {
    @key MetricIdentifier metric_id;
    @key LimitType limit_type;
    UnitIdentifier unit_identifier;
    float value;
  };
  const string GlobalAlarmLimitObjectiveTopic = "GlobalAlarmLimitObjective";

  @doc("This objective is published by a device to acknowledge that it has received the \
    global alarm limit objective for a metric. Eventually its AlarmLimit should \
    indicate that the change has been made. So the are three AlarmLimitXXX topics form \
    an objective-state form of command and control. At any time any participant can see \
    the current state of request, acknowledgment of the request, and implementation of \
    the requested change. \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct LocalAlarmLimitObjective {
    @key UniqueDeviceIdentifier unique_device_identifier;
    @key MetricIdentifier metric_id;
    @key LimitType limit_type;
    UnitIdentifier unit_identifier;
    float value;
  };
  const string LocalAlarmLimitObjectiveTopic = "LocalAlarmLimitObjective";

  @doc("In the current iteration this is status text associated with the device globally. \
    Meant for the global alarm state of the device. For example is the device audibly \
    alarming, visibly alarming, alarming but silenced, etc. \
    Stability: 1 - Experimental")
  @extensibility(MUTABLE)
  struct DeviceAlertCondition {
    @key UniqueDeviceIdentifier unique_device_identifier;
    string<256> alert_state;
  };
  const string DeviceAlertConditionTopic = "DeviceAlertCondition";

  @doc(" This type is used by several topics.")
  @extensibility(MUTABLE)
  struct Alert {
    @key UniqueDeviceIdentifier unique_device_identifier;
    @doc("This is a placeholder for something more harmonized")
    @key string<256> identifier;
    string<256> text;
  };

  @doc("PatientAlert is an alert message related to patient state. In the current iteration \
    publishers may use any identifier they would like to uniquely identify patient \
    alerts. The instance ought to be registered and a sample published when the alarm \
    is triggered. If the associated text changes during the alarm another sample should \
    be published. When the alarm is cancelled the instance should be unregistered. It's \
    still an open question whether alarm samples should be published at regular intervals \
    during the alarm condition. This, unfortunately, might be necessary to assert the \
    liveliness of the alarm instance to late joiners. This is something to investigate \
    with DDS vendors. \
    Stability: 1 - Experimental")
  const string PatientAlertTopic = "PatientAlert";

  @doc("TechnicalAlert is similar to PatientAlert but is meant for technical alarms about \
    the operation of the device. \
    Stability: 1 - Experimental")
  const string TechnicalAlertTopic = "TechnicalAlert";

  @doc("Patient is a simple representation of instances of patient information.  The original \
    driver behind this experiment was to demonstrate the use of unicode (UTF-32) characters \
    in the system and to ensure that various nodes were correctly converting to their own \
    preferred encoding (UTF-16 for Java, UTF-8 for the web, etc.) \
    As a topic describing the many patients this naturally begins an expansion of OpenICE \
    into functionality attributed by the standard for the Integrated Clinical Environment \
    to the ICE Coordinator. \
    Stability: 1 - Experimental")
  struct Patient {
    @key string<16> mrn;
    wstring<256> given_name;
    wstring<256> family_name;
  };
  const string PatientTopic = "Patient";
};
